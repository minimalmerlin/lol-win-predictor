/**
 * Model Statistics Utility
 * Fetches real-time model performance metrics
 */

export interface ModelStats {
  accuracy: number;
  roc_auc: number;
  matches_count: number;
  timestamp: string;
  training_config?: any;
}

/**
 * Fetch model performance stats from static JSON (built during training)
 * Falls back to default values if file not found
 */
export async function getModelStats(): Promise<ModelStats> {
  try {
    // Try to fetch from public/data (generated by training pipeline)
    const response = await fetch('/data/model_performance.json', {
      cache: 'no-store' // Always fetch latest
    });

    if (!response.ok) {
      throw new Error('Performance data not found');
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.warn('Failed to load model stats, using fallback:', error);

    // Fallback to default values
    return {
      accuracy: 0.52,
      roc_auc: 0.5126,
      matches_count: 12834,
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Format accuracy as percentage
 */
export function formatAccuracy(accuracy: number): string {
  return `${(accuracy * 100).toFixed(1)}%`;
}

/**
 * Format match count with K/M suffix
 */
export function formatMatchCount(count: number): string {
  if (count >= 1000000) {
    return `${(count / 1000000).toFixed(1)}M`;
  }
  if (count >= 1000) {
    return `${(count / 1000).toFixed(0)}K`;
  }
  return count.toString();
}

/**
 * Format timestamp to relative time
 */
export function formatTimestamp(timestamp: string): string {
  const date = new Date(timestamp);
  const now = new Date();
  const diffHours = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60));

  if (diffHours < 1) return 'Just updated';
  if (diffHours < 24) return `${diffHours}h ago`;
  const diffDays = Math.floor(diffHours / 24);
  if (diffDays < 7) return `${diffDays}d ago`;
  return date.toLocaleDateString();
}
